<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
	<script type="text/javascript">
//		function NIO(age){
//			console.log(age)
//			var age=99;
//			console.log(age);
//			function age(){
//				console.log(age)			
//			}
//			age();
//		}
//		NIO(100);

//		var z = 10;
//		function foo(){
//			console.log(z);
//		}
//		(function(funArg){
//			var z =20;
//			funArg();
//		})(foo);

//		typeof(null)    //object
//		typeof(NaN)		//number
//		typeof(undefined)	//undefined
//		NaN==undefined;		//false
//		NaN==NaN;			//false

//		var data = [];
//		for(var k=0;k<3;k++){
//			data[k] = function(){
//				console.log(k);
//			}
////			console.log(1);
//		}		//3 3 3 
//		data[0]();
//		data[1]();
//		data[2]();


//		如何判断数据类型为数组类型
//		一、typeof可以判断部分数据类型
//
//		在 JavaScript 里使用 typeof 来判断数据类型，只能区分基本类型，即“number”，”string”，”undefined”，”boolean”，”object” 五种。
//		
//		对于数组、函数、对象来说，其关系错综复杂，使用 typeof 都会统一返回 “object” 字符串。
//		
//		var str="abc";
//		console.log(typeof(str));    //string
//		
//		var num=123;
//		console.log(typeof(num));   //number
//		console.log(num instanceof Number)
//		var tr=false;
//		console.log(typeof(tr));   //boolean
//		
//		var a;
//		console.log(typeof(a));   //undefind
//		
//		//typeof无法区分null、数组、对象类型，这三种用typeof都会返回object
//		如下面的例子：
//		var aa=null;
//		console.log(typeof(aa));   //object 
//		
//		var arr=[];
//		console.log(typeof(arr));    //object
//		
//		var obj={}
//		console.log(typeof(obj));  //object
//		
//		二、instanceof/constructor可以判断数组和对象类型
//		
//		//instanceof方法
//		var arr=[];
//		console.log(arr instance Array); //true
//		
//		//constructor方法
//		var arr={};
//		console.log(arr.constructor==Object); //true
//		
//		三、Object.prototype.toString`判断所有数据类型——简单通用的方法
//		
//		console.log(Object.prototype.toString.call(123)) //[object Number]
//		console.log(Object.prototype.toString.call('123')) //[object String]
//		console.log(Object.prototype.toString.call(undefined)) //[object Undefined]
//		console.log(Object.prototype.toString.call(true)) //[object Boolean]
//		console.log(Object.prototype.toString.call({})) //[object Object]
//		console.log(Object.prototype.toString.call([])) //[object Array]
//		console.log(Object.prototype.toString.call(function(){})) //[object Function]


		// 行内元素，块级元素与空元素
		// 行内元素：a、b、span、img、input、strong、select、label、em、button、textarea
		
		// 块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote
		
		// 空元素:br、meta、hr、link、input、img
		
		
		
		
//		JS 详解 Cookie、 LocalStorage 与 SessionStorage
//			基本概念
//			Cookie
//			Cookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。
//			
//			localStorage
//			localStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。
//			
//			sessionStorage
//			sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。
//		https://www.cnblogs.com/minigrasshopper/p/8064367.html


		
		
		
//		分别写出es6和es5子类继承父类的方法
//		function Father(){
//			this.skill = "打铁";
//			this.show = function(){
//				alert("我是父亲，我会"+this.skill);
//			}
//		}
//		var father = new Father();
//		father.show();
//		
//		es6:
//		class B extends A {
//		  constructor() {
//		    return A.call(this);  //继承属性
//		  }
//		}
//		A.prototype = new B;  //继承方法 

//
//		简述call和apply和bind的异同及应用场景		
//		call，apply和bind都是Function原型中的方法
//				它们在功能上是没有区别的，都是改变this的指向，它们的区别主要是在于方法的实现形式和参数传递上的不同
//		①：函数.call(对象,arg1,arg2....)
//		②：函数.apply(对象，[arg1,arg2,...])
//		③：var ss=函数.bind(对象,arg1,arg2,....)



//		js设计模式

//	        工厂模式：原料、加工、出厂
//	    function createPeople(name,age,like){
//	            var obj = new Object();          //原料
//	            obj.name = name;               //加工
//	            obj.age = age;
//	            obj.like = like;
//	            obj.show = function(){
//	                alert("我叫"+this.name+",今年"+this.age+"岁,喜欢"+this.like)
//	            };
//	            return obj;                     //出厂
//	        }
//	        var obj = createPeople("AAA",23,"LOL");
//	        var obj2 = createPeople("BBB",30,"JAVA");


//		单例模式
//		单个实例，只有一个对象
		
		//多次创建，返回同一个对象
		 
//		function fn(){
//		    if(!fn.obj) { //给函数添加一个属性。 因为函数是全局的，所以该属性一旦添加一直存在;
//		         fn.obj = {
//		             name : “liyang"
//		         };
//		    }
//		    return fn.obj;
//		}
//		var obj1 = new fn();
//		var obj2 = new fn();
//		console.log(obj1 == obj2);
//		
//		
//		组合模式
//		组合模式：把多个对象组成树状结构来表示局部与整体，使得用户可以同时操作单个对象和对象的组合。	
//		
//		
//		
//
//  	观察者模式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。

		
		
//		一、数组扁平化
//	    // 方法一
//	    function Flat1(arr){
//	        return [].concat.apply([],arr);
//	    }
//	
//	    var arr1 = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];
//	    console.log(Flat1(arr1)); // (9) [1, 2, 3, 4, 5, 6, 7, 8, 9]
//	
//	    // 方法二
//	    function Flat2(arr){
//	        var newArr = arr.reduce(function(pre, cur){
//	            return pre.concat(cur)
//	        });
//	        return newArr;
//	    }
//	    var arr1 = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];
//	    console.log(Flat2(arr1)); // (9) [1, 2, 3, 4, 5, 6, 7, 8, 9]
//	
//	    // 方法三
//	    function Flat3(arr){
//	        var newArr =[];
//	        for(var i= 0; i < arr.length; i++){
//	            for(var j=0; j < arr[i].length; j++){
//	                newArr.push(arr[i][j]);
//	            }
//	        }
//	        return newArr;
//	    }
//	    var arr1 = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];
//	    console.log(Flat3(arr1)); // (9) [1, 2, 3, 4, 5, 6, 7, 8, 9]
//	
//	    // 方法四
//	    function Flat4(arr){ // es6
//	        return [].concat(...arr);
//	    }
//	    var arr1 = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];
//	    console.log(Flat4(arr1)); // (9) [1, 2, 3, 4, 5, 6, 7, 8, 9]
//		但是经过测试发现，上述的方法，只能实现两层[]数组的嵌套，如果有多层[]嵌套，就不能正常扁平化了。 
//		
//		
//		
//		扁平化数组（扁平化多层[]嵌套的数组）
//
//	    // 方法五
	    function Flat5(arr){
	        var newArr =[];
	        for(var i= 0; i < arr.length; i++){
	            if(arr[i] instanceof Array){	//instanceof判断arr[i]是否属于Array类
	                newArr = newArr.concat(Flat5(arr[i]));
	                // newArr.push.apply(newArr, Flat5(arr[i]));
	            }else{
	                newArr.push(arr[i]);
	            }
	        }
	        return newArr;
	    }
	
	    var arr1 = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];
	    console.log(Flat5(arr1)); // (9) [1, 2, 3, 4, 5, 6, 7, 8, 9]
//	
	    var arr2 = [[1,2,2],[3, 4, 5, 5],[6, 7, 8, 9,[11,12,[12,13,[14]]]],10];
	    console.log(Flat5(arr2)); // (17) [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10]
//	
//	
//	    // 方法六：es6
//	    const Flat6 = arr => arr.reduce((a, b) => a.concat(Array.isArray(b) ? Flat6(b) : b), []); 
//	
//	    var arr1 = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];
//	    console.log(Flat6(arr1)); // (9) [1, 2, 3, 4, 5, 6, 7, 8, 9]
//	
//	    var arr2 = [[1,2,2],[3, 4, 5, 5],[6, 7, 8, 9,[11,12,[12,13,[14]]]],10];
//	    console.log(Flat6(arr2)); // (17) [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10]
//	
//	
//	    //对应的 es5 代码
//	    var Flat7 = function (arr){
//	        return arr.reduce(function(a,b){
//	            return a.concat(Array.isArray(b)? Flat7(b):b)
//	        },[]);
//	    }
//	    var arr1 = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];
//	    console.log(Flat7(arr1)); // (9) [1, 2, 3, 4, 5, 6, 7, 8, 9]
//	
//	    var arr2 = [[1,2,2],[3, 4, 5, 5],[6, 7, 8, 9,[11,12,[12,13,[14]]]],10];
//	    console.log(Flat7(arr2)); // (17) [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10]
		
		
		
		
		
		
	</script>
</html>
